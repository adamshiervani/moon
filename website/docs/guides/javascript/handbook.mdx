---
title: Monorepo handbook
toc_max_heading_level: 6
---

Utilizing JavaScript in a monorepo can be a daunting task, as there are many ways to structure your
code and to configure your tools. With this handbook, we'll help guide you through this process.

## moon setup

For this part of the handbook, we'll be focusing on [moon](/moon), our build system. To start,
languages in moon act like plugins, where their functionality and support _is not_ enabled unless
explicitly configured. We follow this approach to avoid unnecessary overhead.

### Enabling the language

To enable JavaScript support, define the [`node`](../../config/toolchain#node) setting in
[`.moon/toolchain.yml`](../../config/toolchain), even if an empty object.

```yaml title=".moon/toolchain.yml"
# Enable Node.js
node: {}

# Enable Node.js and override default settings
node:
	packageManager: 'pnpm'
```

This will enable the Node.js platform and provide the following automations around its ecosystem:

- Node modules will automatically be installed if dependencies in `package.json` have changed, or
  the lockfile has changed, since the last time a task has ran.
  - We'll also take `package.json` workspaces into account and install modules in the correct
    location; either the workspace root, in a project, or both.
- Relationships between projects will automatically be discovered based on `dependencies`,
  `devDependencies`, and `peerDependencies` in `package.json`.
  - The versions of these packages will also be automatically synced when changed.
- Tasks can be [automatically inferred](../../config/toolchain#infertasksfromscripts) from
  `package.json` scripts.
- And much more!

### Utilizing the toolchain

When a language is enabled, moon by default will assume that the language's binary is available
within the current environment (typically on `PATH`). This has the downside of requiring all
developers and machines to manually install the correct version of the language, _and to stay in
sync_.

Instead, you can utilize [moon's toolchain](../../concepts/toolchain), which will download and
install the language in the background, and ensure every task is executed using the exact version
across all machines.

Enabling the toolchain is as simple as defining the [`node.version`](../../config/toolchain#version)
setting.

```yaml title=".moon/toolchain.yml"
# Enable Node.js toolchain with an explicit version
node:
	version: '18.0.0'
```

### Using `package.json` names and scripts

If you're looking to prototype moon, or reduce the migration effort to moon tasks, you can configure
moon to inherit `package.json` scripts, and internally convert them to moon tasks. This can be
achieved with the [`node.inferTasksFromScripts`](../../config/toolchain#infertasksfromscripts)
setting.

```yaml title=".moon/toolchain.yml"
node:
	inferTasksFromScripts: true
```

Furthermore, if you'd like to reference projects by their package name (both in configuration and on
the command line), instead of the moon project name, enable the
[`node.aliasPackageNames`](../../config/toolchain#aliaspackagenames) setting.

```yaml title=".moon/toolchain.yml"
node:
	aliasPackageNames: 'name-and-scope'
```

> These are not enabled by default as we want to encourage the
> [use of moon tasks](../../faq#can-we-use-packagejson-scripts).

## Repository structure

JavaScript monorepo's work best when projects are split into applications and packages, with each
project containing its own `package.json` and dependencies. For small repositories, the following
structure typically works well:

```
/
├── package.json
├── apps/
│   └── web/
|       ├── ...
│       └── package.json
└── packages/
    ├── components/
    |   ├── ...
    │   └── package.json
    ├── theme/
    |   ├── ...
    │   └── package.json
    └── utils/
        ├── ...
        └── package.json
```

For large repositories, grouping projects by team or department helps with ownership and
organization. With this structure, applications and libraries can be nested at any depth.

```
/
├── package.json
├── infra/
│   └── ...
├── internal/
│   └── ...
├── payments/
│   └── ...
└── shared/
    └── ...
```

### Applications

...

### Packages

Packages (also known as a libraries)...

## Dependency management

### Workspaces

### Dev deps in root

### Prod deps in project

## Code sharing

### Internal packages

### External packages

## Bundler integration

### Hot module reloading (HMR)
